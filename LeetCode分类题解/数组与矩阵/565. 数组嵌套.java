class Solution {
    public int arrayNesting(int[] nums) {
        /**
         * 1.首先访问数组的第一个元素，将该元素的值作为索引，用于访问下一个元素
         * 2.访问过的元素置为-1，在后续遍历中如果遇到-1的元素，则表示先前访问过，退出循环
         * 本问题的关键在于：数组中没有重复的元素，所以每组集合是唯一的，不分访问顺序的先后
         * 例如{5,6,2,0}，可以从5处开始访问，也可以从6,2,0任意一处开始访问，访问到最后的结果
         * 是一样的。而对于不在这个序列中的元素，例如4,3等，无论怎样跳转，也不会访问到5,6,2,0
         * 这几个数字，因此，访问到5,6,2,0并置为-1时，并不会对其他数字的查找造成干扰
         */
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            int count = 0;
            for (int j = i; nums[j] != -1; ) { // 注意这里j从i开始，且没有j++，下一个j指向t
                count++;
                // 使用t保存当前遍历到的元素的值，作为下次访问的索引
                int t = nums[j];
                // 将访问过的元素置为-1
                nums[j] = -1;
                // 将下一个要访问的元素的下标j置为t
                j = t;
            }
            max = Math.max(max, count);
        }
        return max;
    }
}